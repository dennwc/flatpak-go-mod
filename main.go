package main

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"golang.org/x/mod/modfile"
)

var (
	fOut      = flag.String("out", ".", "output directory")
	fDstPref  = flag.String("dest-pref", "", "destination prefix for generated sources directives")
	fLinePref = flag.String("line-pref", "", "line prefix for YAML file")
)

func main() {
	flag.Parse()
	if err := run(*fOut, *fDstPref, flag.Arg(0)); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func run(out, pref, path string) error {
	if err := goModVendor(path); err != nil {
		return err
	}
	if err := os.Rename(filepath.Join(path, "vendor", "modules.txt"), filepath.Join(out, "modules.txt")); err != nil {
		return err
	}
	if err := os.RemoveAll(filepath.Join(path, "vendor")); err != nil {
		return err
	}
	mods, err := goModDownloadJSON(path)
	if err != nil {
		return err
	}

	fpath := filepath.Join(path, "go.mod")
	data, err := os.ReadFile(fpath)
	if err != nil {
		return err
	}
	gomod, err := modfile.Parse(fpath, data, nil)
	if err != nil {
		return err
	}

	replaced := make(map[string]string)
	for _, m := range gomod.Replace {
		replaced[m.New.Path] = m.Old.Path
	}

	y, err := os.Create(filepath.Join(out, "go.mod.yml"))
	if err != nil {
		return err
	}
	defer y.Close()

	lpref := *fLinePref

	y.WriteString(lpref + "# Workaround for Go modules generated by github.com/dennwc/flatpak-go-mod\n")

	y.WriteString(lpref + "- type: file\n")
	y.WriteString(lpref + "  path: modules.txt\n")
	fmt.Fprintf(y, lpref+"  dest: %svendor\n", pref)
	y.WriteString("\n")

	for _, m := range mods {
		dst, ok := replaced[m.Path]
		if !ok {
			dst = m.Path
		}
		h, err := sha256sum(m.Zip)
		if err != nil {
			return err
		}
		i := strings.Index(m.Zip, "download")
		if i < 0 {
			return fmt.Errorf("unsupported zip file path: %q", m.Zip)
		}
		y.WriteString(lpref + "- type: archive\n")
		fmt.Fprintf(y, lpref+"  url: https://proxy.golang.org/%s\n", m.Zip[i+9:])
		fmt.Fprintf(y, lpref+"  strip-components: %d\n", strings.Count(m.Path, "/")+1)
		fmt.Fprintf(y, lpref+"  dest: %svendor/%s\n", pref, dst)
		fmt.Fprintf(y, lpref+"  sha256: %s\n", h)
		y.WriteString("\n")
	}
	return nil
}

func execIn(path string, cmd string, args ...string) error {
	c := exec.Command(cmd, args...)
	c.Dir = path
	c.Stderr = os.Stderr
	return c.Run()
}

func goModVendor(path string) error {
	return execIn(path, "go", "mod", "vendor")
}

type Module struct {
	Path     string
	Version  string
	Info     string
	GoMod    string
	Zip      string
	Dir      string
	Sum      string
	GoModSum string
}

func goModDownloadJSON(path string) ([]Module, error) {
	c := exec.Command("go", "mod", "download", "-json")
	c.Dir = path
	c.Stderr = os.Stderr
	var buf bytes.Buffer
	c.Stdout = &buf
	if err := c.Run(); err != nil {
		return nil, err
	}
	dec := json.NewDecoder(&buf)
	var out []Module
	for {
		var m Module
		err := dec.Decode(&m)
		if err == io.EOF {
			break
		} else if err != nil {
			return out, err
		}
		out = append(out, m)
	}
	return out, nil
}

func sha256sum(path string) (string, error) {
	f, err := os.Open(path)
	if err != nil {
		return "", err
	}
	defer f.Close()
	h := sha256.New()
	_, err = io.Copy(h, f)
	if err != nil {
		return "", err
	}
	return hex.EncodeToString(h.Sum(nil)), nil
}
