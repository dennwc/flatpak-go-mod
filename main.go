package main

import (
	"bufio"
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/goccy/go-yaml"

	"golang.org/x/mod/modfile"
)

var (
	fOut        = flag.String("out", ".", "output directory")
	fDstPref    = flag.String("dest-pref", "", "destination prefix for generated sources directives")
	fLinePref   = flag.String("line-pref", "", "line prefix for YAML/JSON file")
	fJSON       = flag.Bool("json", false, "use JSON instead of YAML for output")
	fModuleName = flag.String("module-name", "", "optional Flatpak module name (mymodule produces mymodule.go.mod.json and mymodule.modules.txt)")
)

func main() {
	flag.Parse()
	if err := run(*fOut, *fDstPref, *fLinePref, *fModuleName, flag.Arg(0)); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func run(out, pref, lpref, moduleName, path string) error {
	if err := goModVendor(path); err != nil {
		return err
	}

	modulesTxtName := "modules.txt"
	goModOutName := "go.mod.yml"
	if *fJSON {
		goModOutName = "go.mod.json"
	}

	if moduleName != "" {
		modulesTxtName = moduleName + ".modules.txt"
		if *fJSON {
			goModOutName = moduleName + ".go.mod.json"
		} else {
			goModOutName = moduleName + ".go.mod.yml"
		}
	}

	if err := os.Rename(filepath.Join(path, "vendor", "modules.txt"), filepath.Join(out, modulesTxtName)); err != nil {
		return err
	}
	if err := os.RemoveAll(filepath.Join(path, "vendor")); err != nil {
		return err
	}
	mods, err := goModDownloadJSON(path)
	if err != nil {
		return err
	}

	fpath := filepath.Join(path, "go.mod")
	data, err := os.ReadFile(fpath)
	if err != nil {
		return err
	}
	gomod, err := modfile.Parse(fpath, data, nil)
	if err != nil {
		return err
	}

	replaced := make(map[string]string)
	for _, m := range gomod.Replace {
		replaced[m.New.Path] = m.Old.Path
	}

	outPath := filepath.Join(out, goModOutName)

	f, err := os.Create(outPath)
	if err != nil {
		return err
	}
	defer f.Close()

	modulesTxtEntry := map[string]any{
		"type": "file",
		"path": modulesTxtName,
		"dest": fmt.Sprintf("%svendor", pref),
	}
	if moduleName != "" {
		modulesTxtEntry["dest-filename"] = "modules.txt" // Go, when running in flatpak-builder, will still expect the file to be at modules.txt
	}
	files := []map[string]any{modulesTxtEntry}

	for _, m := range mods {
		dst, ok := replaced[m.Path]
		if !ok {
			dst = m.Path
		}
		h, err := sha256sum(m.Zip)
		if err != nil {
			return err
		}
		i := strings.Index(m.Zip, "download")
		if i < 0 {
			return fmt.Errorf("unsupported zip file path: %q", m.Zip)
		}
		files = append(files, map[string]any{
			"type":             "archive",
			"url":              fmt.Sprintf("https://proxy.golang.org/%s", m.Zip[i+9:]),
			"strip-components": strings.Count(m.Path, "/") + 1,
			"dest":             fmt.Sprintf("%svendor/%s", pref, dst),
			"sha256":           h,
		})
	}

	if *fJSON {
		if _, err := f.WriteString(lpref); err != nil {
			return err
		}

		enc := json.NewEncoder(f)
		enc.SetIndent(lpref, "  ")
		if err := enc.Encode(files); err != nil {
			return err
		}
	} else {
		if _, err := f.WriteString(fmt.Sprintf("%v# Workaround for Go modules generated by github.com/dennwc/flatpak-go-mod\n", lpref)); err != nil {
			return err
		}

		buf := new(bytes.Buffer)
		enc := yaml.NewEncoder(buf)
		if err := enc.Encode(files); err != nil {
			return err
		}
		if err := enc.Close(); err != nil {
			return err
		}
		if err := indent(f, buf, lpref); err != nil {
			return err
		}
	}

	return nil
}

func indent(w io.Writer, r io.Reader, lpref string) error {
	sc := bufio.NewScanner(r)
	for sc.Scan() {
		if _, err := fmt.Fprintf(w, "%s%s\n", lpref, sc.Text()); err != nil {
			return err
		}
	}
	return sc.Err()
}

func execIn(path string, cmd string, args ...string) error {
	c := exec.Command(cmd, args...)
	c.Dir = path
	c.Stderr = os.Stderr
	return c.Run()
}

func goModVendor(path string) error {
	return execIn(path, "go", "mod", "vendor")
}

type Module struct {
	Path     string
	Version  string
	Info     string
	GoMod    string
	Zip      string
	Dir      string
	Sum      string
	GoModSum string
}

func goModDownloadJSON(path string) ([]Module, error) {
	c := exec.Command("go", "mod", "download", "-json")
	c.Dir = path
	c.Stderr = os.Stderr
	var buf bytes.Buffer
	c.Stdout = &buf
	if err := c.Run(); err != nil {
		return nil, err
	}
	dec := json.NewDecoder(&buf)
	var out []Module
	for {
		var m Module
		err := dec.Decode(&m)
		if err == io.EOF {
			break
		} else if err != nil {
			return out, err
		}
		out = append(out, m)
	}
	return out, nil
}

func sha256sum(path string) (string, error) {
	f, err := os.Open(path)
	if err != nil {
		return "", err
	}
	defer f.Close()
	h := sha256.New()
	_, err = io.Copy(h, f)
	if err != nil {
		return "", err
	}
	return hex.EncodeToString(h.Sum(nil)), nil
}
