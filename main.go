package main

import (
	"bufio"
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/goccy/go-yaml"

	"golang.org/x/mod/modfile"
)

var (
	fOut      = flag.String("out", ".", "output directory")
	fDstPref  = flag.String("dest-pref", "", "destination prefix for generated sources directives")
	fLinePref = flag.String("line-pref", "", "line prefix for YAML/JSON file")
	fJSON     = flag.Bool("json", false, "use JSON instead of YAML for output")
)

func main() {
	flag.Parse()
	if err := run(*fOut, *fDstPref, *fLinePref, flag.Arg(0)); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func run(out, pref, lpref, path string) error {
	if err := goModVendor(path); err != nil {
		return err
	}
	if err := os.Rename(filepath.Join(path, "vendor", "modules.txt"), filepath.Join(out, "modules.txt")); err != nil {
		return err
	}
	if err := os.RemoveAll(filepath.Join(path, "vendor")); err != nil {
		return err
	}
	mods, err := goModDownloadJSON(path)
	if err != nil {
		return err
	}

	fpath := filepath.Join(path, "go.mod")
	data, err := os.ReadFile(fpath)
	if err != nil {
		return err
	}
	gomod, err := modfile.Parse(fpath, data, nil)
	if err != nil {
		return err
	}

	replaced := make(map[string]string)
	for _, m := range gomod.Replace {
		replaced[m.New.Path] = m.Old.Path
	}

	yPath := filepath.Join(out, "go.mod.yml")
	if *fJSON {
		yPath = filepath.Join(out, "go.mod.json")
	}

	y, err := os.Create(yPath)
	if err != nil {
		return err
	}
	defer y.Close()

	yamlData := map[string]interface{}{
		"comment": "Workaround for Go modules generated by github.com/dennwc/flatpak-go-mod",
		"files": []interface{}{
			map[string]interface{}{
				"type": "file",
				"path": "modules.txt",
				"dest": fmt.Sprintf("%svendor", pref),
			},
		},
	}

	for _, m := range mods {
		dst, ok := replaced[m.Path]
		if !ok {
			dst = m.Path
		}
		h, err := sha256sum(m.Zip)
		if err != nil {
			return err
		}
		i := strings.Index(m.Zip, "download")
		if i < 0 {
			return fmt.Errorf("unsupported zip file path: %q", m.Zip)
		}
		yamlData["files"] = append(yamlData["files"].([]interface{}), map[string]interface{}{
			"type":             "archive",
			"url":              fmt.Sprintf("https://proxy.golang.org/%s", m.Zip[i+9:]),
			"strip-components": strings.Count(m.Path, "/") + 1,
			"dest":             fmt.Sprintf("%svendor/%s", pref, dst),
			"sha256":           h,
		})
	}

	buf := new(bytes.Buffer)
	if *fJSON {
		if _, err := y.WriteString(lpref); err != nil {
			return err
		}

		encoder := json.NewEncoder(y)
		if len(lpref) == 0 {
			encoder.SetIndent("", "  ")
		} else {
			encoder.SetIndent(lpref, "  ")
		}

		if err := encoder.Encode(yamlData); err != nil {
			return err
		}
	} else {
		encoder := yaml.NewEncoder(buf)
		if err := encoder.Encode(yamlData); err != nil {
			return err
		}

		if err := encoder.Close(); err != nil {
			return err
		}

		scanner := bufio.NewScanner(buf)
		for scanner.Scan() {
			if _, err := fmt.Fprintf(y, "%s%s\n", lpref, scanner.Text()); err != nil {
				return err
			}
		}

		if err := scanner.Err(); err != nil {
			return err
		}
	}

	return nil
}

func execIn(path string, cmd string, args ...string) error {
	c := exec.Command(cmd, args...)
	c.Dir = path
	c.Stderr = os.Stderr
	return c.Run()
}

func goModVendor(path string) error {
	return execIn(path, "go", "mod", "vendor")
}

type Module struct {
	Path     string
	Version  string
	Info     string
	GoMod    string
	Zip      string
	Dir      string
	Sum      string
	GoModSum string
}

func goModDownloadJSON(path string) ([]Module, error) {
	c := exec.Command("go", "mod", "download", "-json")
	c.Dir = path
	c.Stderr = os.Stderr
	var buf bytes.Buffer
	c.Stdout = &buf
	if err := c.Run(); err != nil {
		return nil, err
	}
	dec := json.NewDecoder(&buf)
	var out []Module
	for {
		var m Module
		err := dec.Decode(&m)
		if err == io.EOF {
			break
		} else if err != nil {
			return out, err
		}
		out = append(out, m)
	}
	return out, nil
}

func sha256sum(path string) (string, error) {
	f, err := os.Open(path)
	if err != nil {
		return "", err
	}
	defer f.Close()
	h := sha256.New()
	_, err = io.Copy(h, f)
	if err != nil {
		return "", err
	}
	return hex.EncodeToString(h.Sum(nil)), nil
}
